\chapter[Overall Conclusions]{Overall Conclusions}
\label{ch:conclusions}
%\containsfigures{Summary of Conclusions}
%\containslistings{Summary of Conclusions}
%\containstables{Summary of Conclusions}

\chapterepigraph{Haskell is an abstract research language used only in academia, education, banking, stock trading, circuit design, embedded systems, cryptography, operating systems research, bioinformatics, phone apps, and web services.}{Jafet, quoted in \emph{Haskell Weekly News} Issue 265}

\newthought{Much has been learnt over the course of this project}, but as always it is hard to crystallise the full advantage of personal experience into an widely accessible form. The importance of continued research into software design principles is clear: software continues to be a driving force for society and computer use is still increasing at a brisk pace,\cite{borodovsky2006marching} yet actually writing software remains difficult and error prone.\cite[1em]{paulk1993capability} 

This project aimed to show the paradigm of functional programming in action, and specifically the language Haskell. What was once considered merely a research language is now finding uses in many places in industry, and has an active and numerous online community. Haskell and FP remain outside of the mainstream, however, and education and encouragement will be required before these techniques can be widely taken advantage of. This project has attempted to contribute to this agenda by demonstrating that Haskell is effective in a field thought normally to be the preserve only of C++: that of game programming. 

In order to be sure this approach would be viable, various aspects of the method needed to be carefully considered, as detailed in Chapter~\ref{ch:rd}. The most important point to note here is that the game, \emph{Project Serenity}, was designed purely on the merit of being a good game that was achievable in the time frame, \emph{and that no considerations of what would best suit the language it was to be written in}. This is crucial to the conclusions that may now be drawn.

The details of developing Project Serenity --- as detailed in Chapters \ref{ch:game} and and \ref{ch:guide} --- have held some surprises, but the overall experience really has been like any other software project. Some problems were circumnavigated easily, others required some time and the invention of novel solutions. Some parts of the implementation, such as the AI framework and data model, very much suited the standard functional approach, whereas others, such as the GUI framework required some thought to code in a functional way. Advantages and disadvantages to Haskell were apparent, and have been discussed. But the main finding to be stressed is that the disadvantages were small: the difference between the classical problems `suited' to FP, and areas such as graphics and networking --- that people assume would be difficult or impossible --- are either small or non-existent. The hardest problems to be overcome during the project were instead from unexpected directions and generally not related to the functional paradigm itself, such as dependency problems with Cabal (see Section~\ref{ssec:dephell}).

It is important to stress this point, and it can be seen as the most important point that this project has aimed to demonstrate. When talking about the project during the course of the development, the project team were asked frequently questions like `what parts of the implementation really suited Haskell / really didn't suit Haskell', or 'how has the game you have designed been made to really demonstrate FP'. The point is that the game was designed simply to be a good game, and the development was \emph{all} eminently doable with Haskell. Some areas were harder than others, but this would be the same in any language. If Project Serenity is to have demonstrated anything, it is that the advantages of FP really do exist (testability, maintainability, equational reasoning, etc) while most of the usually cited disadvantages (low performance, hard to understand, cannot handle IO well, even lack of library support) do not. It follows that the real barrier to entry to functional languages like Haskell is not a technical aspect of the language --- as often claimed --- but merely a lack of familiarity with the paradigm.

\section{The Importance of Design Patterns}

One of the main weapons brought to bear against software complexity is that of design patterns, and their importance as software development tools is well established.\sidenote{See, for example, the well renown software practice guide: \bibentry{martin2003agile}.} However, because FP can be so different from OO programming, different design patterns are required; or, alternatively, a different perspective on the \emph{same} underlying principles is required. Therefore, a big focus in the presentation of the results in this report, especially those in Chapter~\ref{ch:guide}, is on design patterns for the functional programmer. This focus is to enable functional techniques to be accessible to a wider audience than the usual academic style of research into these languages usually allows.

Many of the techniques used in Haskell programming --- such as use of Monads, Monoids, Arrows, etc --- has come about through mathematical results and reasoning. Category theory has, somewhat surprisingly, turned out to be a rich source of design patterns to be used in practical programming. While one does not need to know anything about category theory to actually make use of any of these results, many of the best Haskell techniques discovered in recent years (such as separation of concerns with free monads) are still underused because they are yet to be translated from mathematics into the language of software design patterns. One of the main reasons for this is, of course, that these developments are very new, and that currently techniques like these are being invented and refined at a very rapid pace. Research normally concentrates on one particular area or design pattern without bringing the full picture into view. It is for these reasons that this project has taken the relatively novel approach of ``development as research''.

\section{Development as Research}

The aspect of this project that makes it unusual, especially for a fourth year group project, is the two layered approach. There is the game itself, which as previously stated was designed independently of all other concerns. This part of the project was a software development project pure and simple, with a customer and a product delivered at the end. But interleaved with this was the primary concern of evaluating Haskell as a development language. The novel idea here is that the first part allows for greater value in the second --- value which isn't available in research that focuses only on a single use or pattern. 

As this is a new and largely unparalleled idea (See Section~\ref{sec:litRevDesigningGame}) the method is somewhat unrefined. Keeping track of the research concern while in active development can be difficult, and for this reason great care was taken to record problems or notable events during development. But it is likely that further improvements can be made if future projects of a similar nature are undertaken. It is possible, for example, that undertaking two implementations of a design simultaneously in different languages would yield further insights. 

\section{Limitations of the Project, and Recommendations for Future Work}

The main limitation of the project has been that, due to time constraints, the complete life cycle of the game could not be completed. The development schedule that was initially planned proved to be quite ambitious, as is often the case in such projects (see Chapter~\ref{ch:pm} for more details). This has meant that the extensive playtesting that was originally planned was not able to be completed, and some of the aspects of coding in Haskell (i.e. maintenance and reuse) have not been as thoroughly tested as they might have been. Despite this, it can be said that the time available was as well spent as could practically be expected.

Once the academic considerations of sharing work before it is marked are no longer relevant, it is planned to open source at least part if not all of the Project Serenity code. It is hoped that work on the game will continue and eventually finished. 

While the project does try and infer conclusions about functional programming in general, many of the conclusions can only be said to apply to Haskell itself. Future work could contrast and compare many different languages being used for similar projects, and what design patterns are similar and can apply more universally. For example, it has been suggested that continuation mechanisms in many languages can be used like the Haskell `do' notation to code monad expressions.\cite{piponi2008}

The content of Chapter~\ref{ch:guide} is an attempt at a `guide' to design patterns for Haskell programming, but much more work on this subject is possible, and indeed desirable. Free monads, lenses, arrows, functional reactive programming, etc, are all active development areas; but there is still a paucity of full guides on how to use these techniques in tandem in a large project. Indeed, a whole book on the subject would be possible.

If the advantages of Haskell and other functional languages are to be be as widely available as possible, routes to understanding them and using them from mainstream development are required. Much work could be done on comparing and contrasting functional from imperative design patterns. 

\section{Summary}

It has been demonstrated that developing a game fit for the current independent market is entirely feasible using the Haskell language. The game was designed purely on the merits of being a good game, not to be well suited to a functional implementation. None of the problems usually touted against the use of functional languages for such projects were encountered, including in areas requiring heavy use of IO, such as graphics and networking. A number of design patterns were found to be especially advantageous, details of which are to be found in Chapter~\ref{ch:guide}. 

There are many advantages to the use of functional languages, yet they are often not used for ill-founded reasons. This project has shown that Haskell is an extremely attractive language, and suggests that it should be taken seriously as an industry tool.

