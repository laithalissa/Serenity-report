\section{Graphics Programming in Haskell}

% OpenGL, Gloss etc

\begin{marginfigure}
	\includegraphics{res/gloss/gloss-tree.png}
	\vspace{1em}
	\includegraphics{res/gloss/gloss-styrene.png}
	\caption[Gloss example screens.]{Gloss example screens from \url{gloss.ouroborus.net/}.}
	\label{fig:gloss}
\end{marginfigure}

Any game is clearly going to involve graphics in some capacity or another, but graphics are not something that at first sight seem suited to a functional language. There are, however, various graphical frameworks and bindings available for Haskell.

For the purposes of the Serenity project, the choice basically boiled down to three options. Firstly, there are bindings directly to OpenGL available; which would provide the most flexibility but also likely the most development time. Secondly there are the bindings to the SDL engine, along with all the various tools provided with its framework. Many of the existing games written in Haskell use SDL. Lastly there is the use of the simple but effective layer over GLUT and OpenGL provided by the Gloss library.

This was not an easy decision, and some time went into making it. The direction taken in the Serenity project was to use the Gloss library, mostly because of its simple interface and ease of use, given the limited time and large scope of the rest of the project. The advantages of Gloss can be appreciated by considering the two screens in Figure \ref{fig:gloss}. Both of these examples involve relatively simple code, which is almost entirely pure.

The decision to use Gloss has largely been held up, but there has been some problems due to features it lacks, the most notable being clipping. In the future it would probably be beneficial to replace Gloss with an in house framework providing a layer between the pure graphics code and impure bindings to OpenGL.

Some details of the OpenGL and Gloss approaches are given below to illustrate the differences and tradeoffs involved.

\subsection{Using OpenGL Directly}

\marginnote{{\bf NB} --- The OpenGL code in this section is based on the tutorial at \url{haskell.org/haskellwiki/OpenGLTutorial1} (retrieved April 2013).}
Writing OpenGL code in Haskell is in many ways similar to writing it in C++ or any similar language. OpenGL calls are simply functions in the IO monad, (i.e. functions of type "IO a"), and there are some special primitive types such as "GLFloat". 

Listing~\ref{list:openglbasic} shows a very simple example of drawing an empty circle and a filled circle, and the output is shown in Figure~\ref{fig:openglbasicout}. Normal Haskell style is used to create a circle: using the "map" function and some trigonometry. These are then converted into OpenGL actions and rendered in the display callback. 

\vspace{-0.5em}
\begin{listing}{list:openglbasic}{Simple OpenGL example, drawing an empty circle and a filled circle (output shown in Figure~\ref{fig:openglbasicout}).}{Simple OpenGL example, drawing an empty circle and a filled circle (output shown in Figure~\ref{fig:openglbasicout}).}{}
\end{listing}\vspace{-1.5em}

\functions(myPoints, pointToVertex, renderMyPoints, display, main, flush, displayPrimitive, displayCallback, getArgsAndInitialize, mapM_, createWindow, mainLoop, clear, renderPrimitive)
\begin{haskell}

>import Graphics.Rendering.OpenGL
>import Graphics.UI.GLUT

>myPoints :: GLfloat -> [(GLfloat,GLfloat,GLfloat)]
>myPoints r = map (\k -> (r*sin(2*pi*k/n),r*cos(2*pi*k/n),0.0)) [1..n] 
>  where n = 100

>pointToVertex :: VertexComponent a => (a, a, a) -> IO ()
>pointToVertex (x,y,z) = vertex $ Vertex3 x y z

>renderMyPoints :: GLfloat -> IO ()
>renderMyPoints r = mapM_ pointToVertex (myPoints r)

>main = do 
>  (progname, _) <- getArgsAndInitialize
>  createWindow "OpenGL Example"
>  displayCallback $= display
>  mainLoop

>display = do 
>  clear [ColorBuffer]
>  renderPrimitive LineLoop (renderMyPoints 1)
>  renderPrimitive TriangleFan (renderMyPoints 0.5)
>  flush

\end{haskell}
\begin{marginfigure}[-25em]
	\hspace{-2em}\includegraphics[width=18em]{res/opengl/openglbasic.png}
	\caption[Output of example OpenGL code in Listing~\ref{list:openglbasic}.]{Output of example OpenGL code in Listing~\ref{list:openglbasic}.}
	\label{fig:openglbasicout}
\end{marginfigure}
\vspace{-1em}
\noindent 
The challenge of programming graphics this way is far less an issue of language paradigm than it is of coding style: maintaining a proper separation between the concerns of basic rendering, specific entity models, the game logic, and so on, is the where main engineering effort is required --- and this is no different in Haskell than in other languages. 

As discussed in the previous section, there are various ways that such separation can be achieved, and that primary among these is the concept of an interim type. It is exactly this approach that is taken by the Gloss library, and this is the main reason Gloss was used in Project Serenity, to avoid the additional time it would take to build the infrastructure to work effectively with OpenGL.

\subsection{Using Gloss}

\begin{marginfigure}
	\hspace{-3em}\includegraphics[width=21em]{res/gloss/glossbasic.png}
	\caption[Output of example Gloss code in Listing~\ref{list:glossbasic}]{Output of example Gloss code in Listing~\ref{list:glossbasic}.}
	\label{fig:glossbasicout}
\end{marginfigure}

Gloss is a layer that sits on top of OpenGL and GLUT providing a much simpler and cleaner API for drawing vector graphics. The Gloss project website claims that ``Gloss hides the pain of drawing simple vector graphics behind a nice data type and a few display functions'', and that using Gloss allows you to ``get something cool on the screen in under 10 minutes''.\sidenote[][1em]{See \url{hackage.haskell.org/package/gloss}} The simplicity of using Gloss compared to raw OpenGL code is shown in Listing~\ref{list:glossbasic} which recreates the simple OpenGL example in Gloss (although the colour of the circles has been changed to make the difference in outputs obvious).

\vspace{-0.5em}
\begin{listing}{list:glossbasic}{Example of simple Gloss usage}{Simple Gloss example, drawing an empty circle and a filled circle (output shown in Figure~\ref{fig:glossbasicout}).}{}
\end{listing}\vspace{-1.5em}

\functions(display, black, circles, color, blue, circleSolid, circle, play, playIO)
\begin{haskell}
>import Graphics.Gloss
>
>main = display (InWindow "Gloss Example" (250, 250) (0, 0)) black circles
>
>circles = Pictures $ map (color blue) [circleSolid 125, circle 250]

\end{haskell}
\noindent
This example simply creates a window named ``Gloss Example'' with a black background and adds the specified "Picture" to it. A "Picture" is the Gloss abstraction of the OpenGL primitives. In the example the picture to display is defined by the "circles" function.

The example in Listing~\ref{list:glossbasic} uses the "display" mode to draw a static picture to the screen. The game mode, started with "play" or "playIO", is obviously more useful when developing a game. It keeps track of a game world, the current state of the game, for which the developer provides callbacks for updating the world every tick and for converting the world to a "Picture". It also allows the programmer to add callbacks for handling input events such as mouse movement and clicks. The Gloss documentation and \texttt{gloss-examples} package are great sources of further information on getting started with game development with Gloss.\sidenote[][-5em]{See \url{hackage.haskell.org/package/gloss} and \url{hackage.haskell.org/package/gloss-examples}}

\subsection{Summary of this section} 
Given the limited time available for the Serenity project, the prebuilt pure interface onto OpenGL provided by the Gloss library was the best option, and this has been born out by the results. A custom made layer that is more appropriate for the needs of a complex game, and more readily adapted to changing requirements, would be beneficial to develop in the future.
