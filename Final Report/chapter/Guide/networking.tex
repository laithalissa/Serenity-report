\section{Network Programming in Haskell}

Fast paced multiplayer games require efficient networking and real time packet delivery.
If this is not provided then the network can become a bottleneck causing the game to
lag or halt. This requirement means that the transmission control protocol (TCP) cannot
be used for game network development because of the implementation of reliability
in TCP. If a packet is lost when using TCP then the receiver stops and waits for that
data to be resent and any new data that is sent is held in a queue until the lost packet
arrives. Therefore, any packet loss on the network causes relatively large pauses in
communication which will cause objects in the game world to stop receiving updates and
the game hangs too.

So, networked multiplayer games that rely on real time network communications must use
the user datagram protocol (UDP) since it does not enforce a stop-and-wait style reliability system.
However, this means that a layer on top of UDP must also be used to implement an efficient
form of reliability, deal with duplicate packets and out of order packets, and create virtual
connections. Unfortunately, whilst Haskell provides a low level networking library, no suitable
library for game networking could be found, so one had to be developed. % XXX Reference chapter 3?

\subsection{Sending and Receiving Packets}

The \texttt{network} package is a low level networking interface that can be used to
send and receive packets using UDP.\sidenote{\url{http://hackage.haskell.org/package/network}}
It provides an easy to use API for creating and sending data over sockets.

\vspace{-0.5em}
\begin{listing}{list:recv}{Example of receiving UDP packets}{Example of receiving UDP packets}{}
\end{listing}\vspace{-1.5em}

\functions(main, port, withSocketsDo, socket, defaultProtocol, bind, socketPrint, recvFrom, putStrLn)
\begin{haskell}
>import Network.Socket
>
>port = 9900
>
>main :: IO ()
>main = withSocketsDo $ do
>  sock <- socket AF_INET Datagram defaultProtocol
>  bind sock (SockAddrInet port iNADDR_ANY)
>  socketPrint sock
>
>socketPrint :: Socket -> IO ()
>socketPrint sock = do
>  (msg, _, _) <- recvFrom sock 512
>  putStrLn msg
>  socketPrint sock

\end{haskell}
\noindent
Listing~\ref{list:recv} shows a simple UDP server which receives packets sent to port 9900
and prints the data that was received. First, this code initialises the networking subsystem
using "withSocketsDo". This is only necessary on machines running the Windows operating system,
but it is best practice to include this for portability. Then a UDP socket is created: "AF_INET"
indicates the use of IPv4, the "Datagram" socket type sets UDP, and a default protocol number
is set. The socket is bound to the specified listening port so that the operating system knows
to forward incoming packets on port 9900 to this socket. The socket is then passed to a loop
which reads incoming data with "recvFrom" and then prints it.

\vspace{-0.5em}
\begin{listing}{list:send}{Example of sending UDP packets}{Example of sending UDP packets}{}
\end{listing}\vspace{-1.5em}

\functions(main, port, withSocketsDo, socket, defaultProtocol, inet_addr, sendTo, close)
\begin{haskell}
>import Network.Socket
>
>port = 9900
>
>main :: IO ()
>main = withSocketsDo $ do
>  sock <- socket AF_INET Datagram defaultProtocol
>  addr <- inet_addr "127.0.0.1"
>  sendTo sock "Hello world!" (SockAddrInet port addr)
>  close sock

\end{haskell}
\noindent
Sending a packet, as shown in Listing~\ref{list:send}, is just as simple. This is a very basic
UDP client that creates a socket and sends a string to port 9900 on the local machine. "inet_addr"
is used to convert a "String" into a network address in host byte order. This address can
then be used as part of an argument that specifies the destination for the "sendTo" function.
Finally the program cleans up after itself by closing the socket.

These two examples show how simple it is to develop basic networking functionality in Haskell.
However, UDP alone, as mentioned previously, is not robust enough to be used for games on real
world networks which experience packet loss and packets arriving out of sequence. So, the next
step is to develop a virtual connection over UDP and build a layer of reliability on top of that.

\subsection{Packets, Connections and Reliability}

Firstly, a simple "Packet" data type is required to represent game packets to be sent out on
the network. This is useful as it allows us to easily add headers to the packet and to pass
around data that is simpler to manipulate and only convert it to a single set of bytes at the
last minute.

\vspace{-0.5em}
\begin{listing}{list:packet}{Simple packet representation}{Simple packet representation}{}
\end{listing}\vspace{-1.5em}

\functions(packetProtocol, packetData)
\begin{haskell}
>import Data.Word (Word32)
>import Data.ByteString.Char8 (ByteString)
>
>data Packet = Packet
>  { packetProtocol :: Word32
>  , packetData :: ByteString
>  }

\end{haskell}
\noindent
The first version of the "Packet" representation is show in Listing~\ref{list:packet}. This
packet only contains a 32 bit protocol identifier and the actual packet data as a string of
bytes. The use of a protocol identifier allows the networking code to ignore any incoming
packets that do not have a matching identifier. This is necessary because client addresses
are not known in advance, so another piece of information is required to distinguish legitimate
packets from any other traffic.

Now these packets must be used, or extended further, to initialise connections. One approach
would be to just start sending packets and assume a connection. When a listening server receives
a valid packet it can recognise it as the establishment of a connection. However, with multiple
computers this might not be robust enough. Therefore, for Project Serenity a brief handshake
sequence, similar to the one employed by TCP, was used. Partially copying the TCP connection
establishment handshake requires adding a flag bit field to the packet header. Each bit represents
a flag which can be on, bit set to one, or off, bit set to zero. Flags can then be specified
to identify connection initialisation.

% SYN, ACK, etc.

\vspace{-0.5em}
\begin{listing}{list:reliable-packet}{Reliable packet data structure}{Reliable packet data structure}{}
\end{listing}\vspace{-1.5em}

\functions(packetSeq, packetAck, packetAckBits, packetFlags)
\begin{haskell}
>import Data.Word (Word32)
>import Data.ByteString.Char8 (ByteString)
>
>data Packet = Packet
>  { packetProtocol :: Word32
>  , packetSeq :: Word32
>  , packetAck :: Word32
>  , packetAckBits :: Word32
>  , packetFlags :: Word8
>  , packetData :: ByteString
>  }

\end{haskell}
\noindent
The problem with TCP was that it forces packets to be delivered in an ordered stream. Instead
of this games require packets to be delivered at a steady rate, but detect any loss and make a
decision at the application level as to whether or not the packet should be resent. The first
step to reliability is knowing which packets were received at the destination; this requires
a method of identifying individual packets. Just like the establishment handshake, this can be
stolen from TCP: each packet contains a sequence number. As packets are sent the sequence number
is incremented monotonically. Listing~\ref{list:reliable-packet} shows the "packetSeq" field in
the "Packet" data structure that holds the sequence number. The receiving end can now identify
which packets it has received, but it still needs a method of relaying this information back
to the sender.

Letting the other end know about packets received is done using acks, short for acknowledgements.
The idea is to record the sequence numbers of incoming packets as the remote sequence number for
the connection. A list of recently received packets is also kept. Then when a packet is sent the
"packetAck" is set to the remote sequence number, i.e.\ the sequence number of the most recently
received packet, and the "packetAckBits" bitfield is set so as to identify which of the 32 packets
prior have also been received. Bit $n$ in the "packetAckBits" bitfield is set to one if the $n$th
most recent packet has been received. Using this method allows 33 acknowledgements per packet.

When a packet is received its ack and ack bitfield can be checked to detect any lost packets.
If an ack for a packet is not received within a certain timeframe then it can be deemed to be
lost. This timeframe is dependent on the rate of network traffic, for example if approximately
30 packets are sent per second then an acknowledgement is expected within one second. Notifications
of packet loss can be passed up to the application layer where a decision can be made on whether
or not to bother resending the packet. This suggests that packets should also include application
level identifiers to ensure that any resent packets can be detected as duplicates if necessary.

% Sequence number wrap around
% Time outs
% Disconnection

% \subsection{Security} ?
%
% Siphash

\subsection{Networking threads}

% Inbox + outbox loops
% TChans
% ConnectionMap

Now a fully fledged networking library is available it needs to be put to use. How should it
be used without impacting the performance of the game animations. One option would be to
ensure that all networking options are non-blocking so that the networking code can be called
during the main game loop. However, for Project Serenity it was decided to use Haskell's
powerful and easy to use support for parallel threads.

The idea was to run two threads: one for incoming messages and the other for outgoing ones.
To send a message it would be put into a shared queue by the main loop. The outgoing thread,
consuming this queue, would read in the message and write it out onto the network. Similarly,
as a message arrives the incoming thread would put it into a separate queue for the main loop
to read from. Writing safe producers and consumers that operate like this is notoriously difficult
to do correctly. Fortunately, however, the software transactional memory library, \texttt{stm},
makes this very simple to do in Haskell.

Software transactional memory is a technique for performing groups of memory operation atomically.\cite{stm}
The idea is similar to that of transactions in databases. A block of code that is called "atomically"
is guaranteed to be isolated from the memory operations of any other thread. Upon completion of the atomic
transaction its transaction log is validated before the changes are committed to memory. If validation
fails, e.g.\ because memory read was altered by another thread during execution, then the changes are
discarded and the block is restarted. The use of transactions removes the complexity of traditional
locks and allows concurrent code to be written with ease.

The \texttt{stm} library provides a transactional first-in-first-out channel, "TChan", that is
perfect for this situation. One thread can write values into the channel whilst another reads
them out in the order they were put in. When a connection is established a "TransportInterface"
is created. This contains two "TChan"s that are unique for the connection, one is the inbox and
the other the outbox. The interface is placed into a map that maps from IP addresses to these
channels. Using the connection map the networking workflow is as follows:

\begin{enumerate}
\item Create a socket and bind it to a known port.
\item Accept incoming requests placing the new connections into the connection map.
\item Spawn two threads which run indefinitely. One deals with the inbox channels; it receives
      incoming messages from the socket and puts them into the inbox "TChan" created for that
      IP address. The other reads in messages from all of the outbox channels and relays them
      onto the network.
\end{enumerate}

\vspace{-0.5em}
\begin{listing}{list:networking-threads}{Spawning threads to deal with network traffic}{Spawning threads to deal with network traffic. This is simplified version of the code in Project Serenity.}{}
\end{listing}\vspace{-1.5em}

\functions(sendAndReceive, forkIO, forever, inboxLoop, outboxLoop, receive, atomically, writeTChan, toList, channelInbox)
\functions(mapM, readAndSend, send, tryReadTChan, channelOutbox)
\begin{haskell}
>type ConnectionMap = Map SockAddr TransportInterface
>
>data TransportInterface = TransportInterface
>  { channelInbox :: TChan Message
>  , channelOutbox :: TChan Message
>  }
>
>sendAndReceive :: ConnectionMap -> Socket -> IO ()
>sendAndReceive connections sock = do
>  forkIO $ forever $ inboxLoop connections sock
>  forkIO $ forever $ outboxLoop connections sock
>  return ()
>  where
>    inboxLoop connections sock = do
>      (message, channels) <- receive connections sock
>      atomically $ writeTChan (channelInbox channels) message
>
>    outboxLoop transport = mapM_ (readAndSend socket) (M.toList connections)
>
>    readAndSend sock (addr, channels) = do
>      message <- atomically $ tryReadTChan (channelOutbox channels)
>      case message of
>        Just m -> send sock m addr
>        Nothing -> return ()

\end{haskell}
\noindent
Listing~\ref{list:networking-threads} shows a simplified version of the code that performs
step three of this workflow in Project Serenity. Two infinite loops are spawned on two new
threads using "forkIO" to spark a new lightweight thread and "forever" to repeat monadic
actions indefinitely. "inboxLoop" calls a function that reads an incoming packet and returns
the message it contained with the "TransportInterface" associated with the sending address.
The message is then atomically written into the inbox channel using "writeTChan". The "outboxLoop"
does the reverse by attempting to read messages from all of the outbox channels --- this is
done with the non-blocking "tryReadTChan" --- and firing off them off onto the network.
This is a great example of how easy it can be write concurrent code using Haskell. It only
takes one line of code to fork a new thread and a couple more to write data into shared
memory free from deadlock or corruption.
