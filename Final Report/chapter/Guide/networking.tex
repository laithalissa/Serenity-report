\section{Network Programming in Haskell}

Fast paced multiplayer games require efficient networking and real time packet delivery.
If this is not provided then the network can become a bottleneck causing the game to
lag or halt. This requirement means that the transmission control protocol (TCP) cannot
be used for game network development because of the implementation of reliability
in TCP. If a packet is lost when using TCP then the receiver stops and waits for that
data to be resent and any new data that is sent is held in a queue until the lost packet
arrives. Therefore, any packet loss on the network causes relatively large pauses in
communication which will cause objects in the game world to stop receiving updates and
the game hangs too.

So, networked multiplayer games that rely on real time network communications must use
the user datagram protocol (UDP) since it does not enforce a stop-and-wait style reliability system.
However, this means that a layer on top of UDP must also be used to implement an efficient
form of reliability, deal with duplicate packets and out of order packets, and create virtual
connections. Unfortunately, whilst Haskell provides a low level networking library, no suitable
library for game networking could be found, so one had to be developed. % XXX Reference chapter 3?

\subsection{Sending and Receiving Packets}

The \texttt{network} package is a low level networking interface that can be used to
send and receive packets using UDP.\sidenote{\url{http://hackage.haskell.org/package/network}}
It provides an easy to use API for creating and sending data over sockets.

\vspace{-0.5em}
\begin{listing}{list:recv}{Example of receiving UDP packets}{Example of receiving UDP packets}{}
\end{listing}\vspace{-1.5em}

\functions(main, port, withSocketsDo, socket, defaultProtocol, bind, socketPrint, recvFrom, putStrLn)
\begin{haskell}
>import Network.Socket
>
>port = 9900
>
>main :: IO ()
>main = withSocketsDo $ do
>  sock <- socket AF_INET Datagram defaultProtocol
>  bind sock (SockAddrInet port iNADDR_ANY)
>  socketPrint sock
>
>socketPrint :: Socket -> IO ()
>socketPrint sock = do
>  (msg, _, _) <- recvFrom sock 512
>  putStrLn msg
>  socketPrint sock

\end{haskell}
\noindent
Listing~\ref{list:recv} shows a simple UDP server which receives packets sent to port 9900
and prints the data that was received. First, this code initialises the networking subsystem
using "withSocketsDo". This is only necessary on machines running the Windows operating system,
but it is best practice to include this for portability. Then a UDP socket is created: "AF_INET"
indicates the use of IPv4, the "Datagram" socket type sets UDP, and a default protocol number
is set. The socket is bound to the specified listening port so that the operating system knows
to forward incoming packets on port 9900 to this socket. The socket is then passed to a loop
which reads incoming data with "recvFrom" and then prints it.

\vspace{-0.5em}
\begin{listing}{list:send}{Example of sending UDP packets}{Example of sending UDP packets}{}
\end{listing}\vspace{-1.5em}

\functions(main, port, withSocketsDo, socket, defaultProtocol, inet_addr, sendTo, close)
\begin{haskell}
>import Network.Socket
>
>port = 9900
>
>main :: IO ()
>main = withSocketsDo $ do
>  sock <- socket AF_INET Datagram defaultProtocol
>  addr <- inet_addr "127.0.0.1"
>  sendTo sock "Hello world!" (SockAddrInet port addr)
>  close sock

\end{haskell}
\noindent
Sending a packet, as shown in Listing~\ref{list:send}, is just as simple. This is a very basic
UDP client that creates a socket and sends a string to port 9900 on the local machine. "inet_addr"
is used to convert a "String" into a network address in host byte order. This address can
then be used as part of an argument that specifies the destination for the "sendTo" function.
Finally the program cleans up after itself by closing the socket.

These two examples show how simple it is to develop basic networking functionality in Haskell.
However, UDP alone, as mentioned previously, is not robust enough to be used for games on real
world networks which experience packet loss and packets arriving out of sequence. So, the next
step is to develop a virtual connection over UDP and build a layer of reliability on top of that.

\subsection{Packets, Connections and Reliability}

Firstly, a simple "Packet" data type is required to represent game packets to be sent out on
the network. This is useful as it allows us to easily add headers to the packet and to pass
around data that is simpler to manipulate and only convert it to a single set of bytes at the
last minute.

\vspace{-0.5em}
\begin{listing}{list:packet}{Simple packet representation}{Simple packet representation}{}
\end{listing}\vspace{-1.5em}

\functions(packetProtocol, packetData)
\begin{haskell}
>import Data.Word (Word32)
>import Data.ByteString.Char8 (ByteString)
>
>data Packet = Packet
>  { packetProtocol :: Word32
>  , packetData :: ByteString
>  }

\end{haskell}
\noindent
The first version of the "Packet" representation is show in Listing~\ref{list:packet}. This
packet only contains a 32 bit protocol identifier and the actual packet data as a string of
bytes. The use of a protocol identifier allows the networking code to ignore any incoming
packets that do not have a matching identifier. This is necessary because client addresses
are not known in advance, so another piece of information is required to distinguish legitimate
packets from any other traffic.

Now these packets must be used, or extended further, to initialise connections. One approach
would be to just start sending packets and assume a connection. When a listening server receives
a valid packet it can recognise it as the establishment of a connection. However, with multiple
computers this might not be robust enough. Therefore, for Project Serenity a brief handshake
sequence, similar to the one employed by TCP, was used. Partially copying the TCP connection
establishment handshake requires adding a flag bit field to the packet header. Each bit represents
a flag which can be on, bit set to one, or off, bit set to zero. Flags can then be specified
to identify connection initialisation.

% SYN, ACK, etc.

\vspace{-0.5em}
\begin{listing}{list:reliable-packet}{Reliable packet data structure}{Reliable packet data structure}{}
\end{listing}\vspace{-1.5em}

\functions(packetSeq, packetAck, packetAckBits, packetFlags)
\begin{haskell}
>import Data.Word (Word32)
>import Data.ByteString.Char8 (ByteString)
>
>data Packet = Packet
>  { packetProtocol :: Word32
>  , packetSeq :: Word32
>  , packetAck :: Word32
>  , packetAckBits :: Word32
>  , packetFlags :: Word8
>  , packetData :: ByteString
>  }

\end{haskell}
\noindent
The problem with TCP was that it forces packets to be delivered in an ordered stream. Instead
of this games require packets to be delivered at a steady rate, but detect any loss and make a
decision at the application level as to whether or not the packet should be resent. The first
step to reliability is knowing which packets were received at the destination; this requires
a method of identifying individual packets. Just like the establishment handshake, this can be
stolen from TCP: each packet contains a sequence number. As packets are sent the sequence number
is incremented monotonically. Listing~\ref{list:reliable-packet} shows the "packetSeq" field in
the "Packet" data structure that holds the sequence number. The receiving end can now identify
which packets it has received, but it still needs a method of relaying this information back
to the sender.

Letting the other end know about packets received is done using acks, short for acknowledgements.
The idea is to record the sequence numbers of incoming packets as the remote sequence number for
the connection. A list of recently received packets is also kept. Then when a packet is sent the
"packetAck" is set to the remote sequence number, i.e.\ the sequence number of the most recently
received packet, and the "packetAckBits" bitfield is set so as to identify which of the 32 packets
prior have also been received. Bit $n$ in the "packetAckBits" bitfield is set to one if the $n$th
most recent packet has been received. Using this method allows 33 acknowledgements per packet.

When a packet is received its ack and ack bitfield can be checked to detect any lost packets.
If an ack for a packet is not received within a certain timeframe then it can be deemed to be
lost. This timeframe is dependent on the rate of network traffic, for example if approximately
30 packets are sent per second then an acknowledgement is expected within one second. Notifications
of packet loss can be passed up to the application layer where a decision can be made on whether
or not to bother resending the packet. This suggests that packets should also include application
level identifiers to ensure that any resent packets can be detected as duplicates if necessary.

% Sequence number wrap around

% \subsection{Security} ?
%
% Siphash

\subsection{Networking threads}

% Inbox + outbox loops
% TChans
% ConnectionMap
