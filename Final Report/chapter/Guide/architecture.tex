\section[Architectural Design --- Separation of Concerns, Encapsulation and File Convetions]{Architectural Design --- Separation of Concerns, \\Encapsulation, and Code Organisation}

% Server vs lock step game design
% Shared parts of implementation between client and server 
% Layout of project
% IO and pure separation

When coming from an OO background, one of the first problems encountered when embarking on a large FP project is how to organise and architect the code. There is a certain paucity of literature pertaining to this issue; and while there are many projects on Hackage that provide good examples, the principles behind them are not always clear.\sidenote{CF Section \ref{sec:fp_review} on page \pageref{cf:code_organisation}. }

There are two related issues here. First is simply what files should have what code in them; and second, how to separate concerns effectively. These can be seen as quite separate issues, but it is helpful to consider them simultaneously here, as should become apparent.

Common practice in OO languages is to have one class per file\sidenote{See \url{www.oracle.com/technetwork/java/codeconv-138413.html} (rev. 1999) and \url{www.possibility.com/Cpp/CppCodingStandard.html\#cflayout} for example. (Accessed April 2013).} but it is not immediately clear what principle in FP should determine the contents of a file. The approach taken in the Serenity project is instead to allow \emph{form} to follow \emph{function} (no pun intended); that is, to allow the desired separation of concerns to drive the module layout --- adjusting as becomes necessary --- rather than a specific type of code concept.

The main separation of concern that every Haskell project is going to contain to some degree or another is between pure and impure code, and so the first thing to be considered in designing an architecture for a project should be how the connection and communication between these areas is going to be managed.
At first sight it would appear that almost all of what happens in a game is IO of some sort or another, but this is not the case. Code can be pure precisely when its behaviour can be defined precisely in terms of its output can be defined precisely in terms of its arguments.\sidenote{CITATION NEEDED} Motion of a particle in space experiencing a force due to gravity, for example, can be defined in terms of pure code. The process of writing log entries into a file will not be, (although the code that output those entries could be).

This is all very well, but does not make it immediately clear how to break down a project's code. The approach taken during the design of Serenity's module structure, and the approach recommended by this guide, is to let the structure of the main loop of each runnable component guide the nature and interface of each module.

To demonstrate how this works, consider the architecture of the Serenity project. As discussed elsewhere,\sidenote{Section \ref{sec:specv2} page \pageref{sec:specv2}.} the game uses a server-client model, but with none or very limited simulation clientside. There are therefore two runnable components, which will share some logic. Each main loop will therefore have two main impure parts: the receiving of IO over the network from the server or client, and local IO (be it output to the screen, logging, or input from the user).
