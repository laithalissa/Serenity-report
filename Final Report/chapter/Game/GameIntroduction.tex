% introduction
% ------------

\newthought{A large part of this project} was purely a software development project to deliver a fun real time strategy game set in space. A lot of the design and development of this game is irrelevant to the research directed portion of the project which aimed to investigate the suitability of Haskell and FP for game development. Instead it rather generic work that is applicable to game development in any programming language. For example, designing the gameplay, implementing a reliable networking architecture, and creating graphical assets to display. This chapter describes the more general part of the project and presents the finished product itself.

The process of designing a game involves taking the basic concept of the game and the system requirements that were created for the specification, and producing a plan for implementing these features. This design is then implemented step by step to iteratively create a working game that fits the original requirements. The major aspects of this design and implementation process will be covered including the server-client architecture, the models and mechanisms that underpin the game concept, the artificial intelligence and path finding systems, and the creation of the assets and graphics that make up the GUI.

The project proceeded in two major phases: the alpha phase that took place during term one, and the beta phase that started in the Christmas holidays and continued through to the end of second term and the Easter holidays. The aim of the alpha stage was to lay the foundations of the game and create a prototype release that comprised of the minimal set of features to be called a `working game'. This foundation would be the infrastructure on which the actual gameplay features could be built. This included a networking architecture and library, basic model of the game components, the basic game loops that would update these models, and finally some assets to be used to represent game entities and a rendering process to display them. The alpha stage produced what was desired, a networked program with a usable GUI. Two or more players could launch the program such that they would communicate with each other. Each player was in charge of their own ship and could control it by clicking on a location for the ship to fly to.

The beta stage started by fixing some bugs and introducing some enhancements to this groundwork. However, the main aim of this stage was to flesh out the game mechanics on top of the foundations. This work introduced the major features of the game including an artificial intelligence framework to handle invidual ship behaviour, a proper GUI menu for launching games, improved graphics and GUI elements to match the mockup drawn up for the specification, and the gameplay mechanisms such as attacking and planetary capture. All of this development culminated in the release of a fully working game in which players have access to an elegant GUI which enables them to easily play a real time strategy game set in space. The following sections will explore the work from both of these stages in greater detail.


\begin{comment}
\newthought{Our project, irrelevant to implementation language}, has a very similar foundation to all games, requiring networking between computers playing the game, graphics engine that can draw the game, assets/sprites for in game entities.

% what does this chapter talk about:
% - how we made the specification a reality
% - design decisions
% - networking architecture
% - graphics architecture
% - GUI layouts
% - resources in game
% - planet capture
% - ship weapons
% - path finding 
% - assets

This chapter describes the design process of the game.
The design process involves taking the abstract system requirements specifies in the specification and producing a design that discusses how these specification requirements will be achieved.
The major aspects of the game will covered, including:
\begin{itemize}
\item server client synchronisation
\item GUI
\item model of the game concepts
\item AI
\item path finding
\end{itemize}

%
%This chapter describe the process of taking the revised specification and converting it into a game design.
%It will cover the major aspects of the project, not in the prospective eye of implementation, but of game design.
%How will the GUI look? What path will the ships take to get to their destination? These high level questions need answers before an implementation can take place.
%The following topics will be covered:
%\begin{description}
%\item[Server Client Synchronisation] The topology of the network, The protocol the server and client will use to sync their game states
%\item[Graphics] insert penis here...
%\end{description}

The game's implementation will be designed with an infrastructure that is at the core. All game features will run on top of this infrastructure, having little dependency on other game features, but having complete dependency on the infrastructure. This architecture allows very module design with regards to game features, allowing new game features to be added to the implementation only a slight modification of the infrastructure to include the new feature. By designing the architecture like this, It facilitates a release based schedule.

A high level specification is now available that specifics the elements of the game. To bring this high level specification to reality, the game design will be broken down into 3 major releases: Alpha, Beta 1, and Beta 2. Each release specifies the game features that must be in the game. Essentially the game design is broken down into game features, with higher priority game features being specified in earlier releases.
Alpha Release is primarily focused on building the game's Infrastructure, this is the core of the game with all the back end logic that is never seen by the player. By the end of Alpha 1 the game infrastructure is mostly complete, and the game is in a state where game logic can now be added on like modules with little dependency 
Beta 1 and Beta 2 are both game feature oriented, building on top of the existing infrastructure, adding features described in the specification. These releases will heavily focus on meeting the specification's specified game features.

% Laying The Foundation
% ---------------------
Terminology was the first step in the conversion process from specification to working game. 
An initial ambiguity was that many of Haskell libraries being looked into had a concept of 'world' which varied dramatically, which in term caused every member of the team to have a different meaning for the word. This caused many misunderstandings until an internal terminology was devised within the team to describe common terms such as 'client state'. Once the terminology hurdle was solved, The team was able to share design ideas efficiently.

By the end of alpha Stage a working 'game' was needed, something that could be used as a base to start adding game features.

The infrastructure must provide a platform that the game features can be implemented on top of, Hence it must contain:
\begin{itemize}
\item Server-Client communication
\item Rendering capabilities for assets
\item Game loop
\item Model of game components
\end{itemize}

Mistakes at this stage will cost heavily later down the line, because so much will depend on the infrastructure. 
\end{comment}
\begin{comment}

alpha stage layout
------------------
features wanted at this stage:
    - networking
    - server client loop
    - game update model (lock-step no no no)
    - ship move orders
    - world rendering(easy debugging)
    - more focus around infrastructure than features

  - lack of libraries, implemeintg our own networking, GUI library.
  - implementation of network library.
  - server and client not distinquished just yet
  - game loop
  - lock-step big part
    - arguments for and against
  - integration of assets into game
  - API for game how entities are added
  - how generating diffs will work

  - infrastructure components
    - networking
    - gameploop
    - how the server and client synchronize
    - graphics


\end{comment}
