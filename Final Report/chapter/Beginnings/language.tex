\section{Working Title for the Game: Project Serenity}

At the outset of the research it was not clear exactly what form the specification of the game would take. For this reason a working title was used to refer to it, and as of now no further title has been substituted. The working title is useful to disambiguate the game itself from the overall project, and is used throughout this document. The title is \emph{Project Serenity}.

\section{Independence of Game Design from Programming Language}

In order for the conclusions of this project to be meaningful, it is important that the game is not designed with the aim of demonstrating FP in mind. If it were, then the apparent performance of the language would be inflated by the nature of the design. It is crucial that the game resembles a standard game project as much as is possible in order for the test to be fair.

In order to enable this as much as is practically possible without having a separate team design the game, several measures were taken. The primary method used was to ban mention of Haskell during design sessions. The priorities of game design were strictly confined to those independent of the implementation, and it was agreed that even if features had to be coded in a more mainstream language in order to include them, they should stay. 

This concern had to be balanced with the requirement to be very aware of the language during actual development in order to document both strengths and weaknesses met in over the course of the project.

\section{On the Choice of Language for the Project}

The following factors were used to judge suitability between languages for use in the project.

\begin{description}
	\item[Strength of Type System] It was desired to use a strong, advanced type system to enable the full benefits of advanced FP techniques.
	\item[Purity] Many of the advantages of FP come only when true separation between pure functional code, and impure `effectful' code, is available.\cite[-10em]{hudak1989conception}
	\item[Concision] Concise but readable code syntax was preferred to verbose or obscure.\sidenote[][-8em]{\bibentry{brooks1995},
also \bibentry{taliaferro1971modularity}, and
\bibentry{wolverton1974cost}.}
	\item[Speed] Due to the domain, a reasonable degree of performance was required of the target code.
	\item[Testing] Good testing support was desirable both from a software development point of view, and the ability to show test-driven techniques in an FP context.\sidenote[][-6em]{See \bibentry{beck1999}.}
	\item[Community and Library Support] Good availability of libraries and a thriving community all vastly aid in development.
	\item[Familiarity] Languages the team already had some experience of would allow for more effort to be spent on the actual project than learning a completely new language, but also any language that was \emph{too} familiar might make some results less applicable.
\end{description}

%TODO
\emph{to be completed}

\subsection{Lisp / Scheme / Clojure}

% PRO:
% (Clojure) Runs on JVM essentially guarantees portability
% (Clojure) Designed with concurrency in mind

% NEUTRAL:
% Some familiarity (CS255, Emacs)

% CON:
% Dynamic typing? (Not the same as strength, but...)

\subsection{Scala}

% PRO:
% Running on JVM essentially guarantees portability

% CON:
% Although full functional support (including libraries for side-effect-less) it is multi-paradigm. Could be prone to 'cheating'?
% Unfamiliar

\subsection{Other ML variants (SML, OCaml, F\#, etc)}

% CON:
% Multi-paradigm, more impure. Considered 'cheating'?

\subsection{Haskell}

% PRO:
% Fits all of the factors mentioned above
% Especially familiarity from CS256

Haskell really fitted all of the factors mentioned above. It is notable for its strong, static type system and its innovative approach to ad-hoc polymorphism through type classes.\cite{wadler1989typeclasses}

The project team were most familiar with Haskell of any functional programming language having studied it as part of a second year module on FP. This would reduce the amount of ramp up time required to get started on the project. However, none of the team had developed a large scale project with Haskell before, so it could not be classified as too familiar.

\subsection{Erlang}

% PRO:
% Designed to be concurrent. Benefits a game were running workers (like networking) in separate threads.

% CON:
% Dynamic typing
% Unfamiliar
